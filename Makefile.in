#**************************************************************************
#*                                                                        *
#*                 The Flambda backend project for OCaml                  *
#*                                                                        *
#*   Copyright 2020--2021 Jane Street Group LLC                           *
#*                                                                        *
#**************************************************************************

.NOTPARALLEL:

# CR mshinwell: Find out how to get something like "set -eu" in effect.
prefix=@prefix@
stage0_prefix=@stage0_prefix@
stage1_prefix=@stage1_prefix@
stage2_prefix=@stage2_prefix@
middle_end=@middle_end@
dune=@dune@

stage1_build=_build/stage1
stage2_build=_build/stage2

# Note that this is assigned with = so it will be expanded lazily. Won't work
# unless ocaml-stage1-Makefile.config has been generated already (see the
# find_arch target below).
arch=$(shell grep '^ARCH=' ocaml-stage1-Makefile.config | cut -d'=' -f2)

# A target to use to make sure that $(arch) will work. It doesn't actually
# find the architecture itself, but it makes sure that it can be found.
.PHONY: find_arch
find_arch: ocaml-stage1-Makefile.config

# Annoyingly, Dune checks all build contexts to make sure they have ocamlc in
# their PATHs, even when only building in a subset of build contexts. So when we
# haven't yet built stage1, the stage2 build context is invalid, and this
# prevents building stage1. So we have to build stage1 in a separate workspace
# that doesn't define stage2 at all. (Sadly, the workspace for stage2 has to
# include *both* contexts so that stage1 can be stage2's host context, so we
# have to be redundant.)
#
# Also, I would love to just define $(dune_stage1) and $(dune_stage2) to have
# both the Dune executable and these flags, but Dune does not allow any flags
# before the name of the command (so "dune build --root=." works but "dune
# --root=. build" does not).
dune_flags_stage1=--workspace=dune-workspace.stage1 --root=.
dune_flags_stage2=--workspace=dune-workspace.stage2 --root=.

# The Flambda backend compiler build proceeds, from cold, in three stages.
# We call these (in order) stage0, stage1 and stage2.  They are documented
# below.

.DEFAULT_GOAL := stage2

# Building stage0 is the same as an upstream compiler build with make.  This is
# done in an rsynced tree to avoid polluting the ocaml/ subdirectory (see
# below for more details).  We need to make sure the separate tree is in
# sync with the ocaml/ directory first, in case files were added or removed.
#
# We use the -i option to rsync in order to short-circuit a null build with
# make, since it seems faster.
#
# CR-someday mshinwell: We should replace this with a coldstart using dune.
.PHONY: stage0
stage0: ocaml-stage0-config.status
	rm -f .rsync-output
	rsync -i -a --filter=':- $$(pwd)/ocaml/.gitignore' \
	  $$(pwd)/ocaml/ $$(pwd)/_build0 \
	  | grep -v '/$$' \
	  | tee .rsync-output
	if [ -s .rsync-output ] || ! [ -d $(stage0_prefix) ]; then \
	  $(MAKE) force-stage0; \
	fi

.PHONY: force-stage0
force-stage0: ocaml-stage0-config.status
	cp ocaml-stage0-config.status _build0/config.status
	(cd _build0 && \
	  ./config.status && \
	  $(MAKE) world.opt && \
	  $(MAKE) ocamlnat)
	(cd _build0 && $(MAKE) install)

# stage1 builds the Flambda backend compiler using the stage0 compiler.
#
# At the end, we have a working Flambda backend compiler, equivalent to having
# done "make ocamlopt" upstream.  For testing with a broken middle or backend,
# e.g. if the stdlib doesn't compile, you can stop here and run
# _build/stage1/flambda_backend_main.exe.
#
# At this point we don't yet have a standard library and a set of otherlibs
# whose .cmx files are compatible with this new compiler.  Neither are the
# Flambda backend compiler, or the compilerlibs that form it, built with the
# Flambda backend compiler itself.  These steps comprise stage2.
#
# CR-someday lmaurer: In principle, since Dune is building both stage1 and
# stage2 and the stage2 Dune workspace is a superset of the stage1 one, it
# shouldn't be necessary to build stage1 and stage2 in separate invocations of
# Dune. As of this writing, however, Dune doesn't recognize that the ocamlc
# in stage2's PATH is itself a build target (I suspect because it resolves
# ocamlc before building anything), so it tries to build stage2 with whatever
# compiler is in the user's PATH.
.PHONY: stage1
stage1: ocaml-stage1-config.status stage0 config_files find_arch
	ARCH=$(arch) $(dune) build @$(stage1_build)/install $(dune_flags_stage1) \
	  --profile=release
	(cd $(stage1_prefix)/bin && \
	  rm -f ocamllex && \
	  ln -s ocamllex.opt ocamllex)

# CR mshinwell: We should add targets that don't use --profile=release, for
# speed, and also ensuring that warnings are errors.  We should also consider
# adding a new Dune profile that is like "release" but has warnings as errors.

# stage2 rebuilds the whole compiler system with the Flambda backend compiler
# itself, including the stdlib, otherlibs, compilerlibs, etc.  The result is
# equivalent to having done "make world.opt && make ocamlnat" upstream.
.PHONY: stage2
stage2: ocaml-stage2-config.status find_arch stage1
	ARCH=$(arch) $(dune) build $(dune_flags_stage2) --profile=release \
		@$(stage2_build)/install

# This target is like a polling version of upstream "make ocamlopt" (based
# on the stage1 target, above).
# It is likely to be what's most often wanted for day-to-day development of
# features, especially large ones that take a long time to get to compile,
# in the middle end and backend.
.PHONY: hacking
hacking: ocaml-stage1-config.status stage0 config_files find_arch
	ARCH=$(arch) $(dune) build $(dune_flags_stage2) -w --profile=release \
	  @$(stage1_build)/install


## Test compilation of backend-specific parts
ARCHES=amd64 arm64
ARCH_SPECIFIC =\
  backend/arch.ml backend/proc.ml backend/CSE.ml backend/selection.ml \
  backend/scheduling.ml backend/reload.ml backend/emit.ml

# This rule provides a quick way to check that machine-dependent
# files compiles fine for a foreign architecture (passed as ARCH=xxx).
# Based on stage1 target above.
.PHONY: check_arch
check_arch: ocaml-stage1-config.status stage0 \
	config_files
	@echo "========= CHECKING backend/$(ARCH) =============="
	rm -f $(ARCH_SPECIFIC)
	$(dune) build $(dune_flags_stage1) --profile=release \
	  $(stage1_build)/ocamloptcomp.cma
	rm -f $(ARCH_SPECIFIC)

.PHONY: check_all_arches
check_all_arches: ocaml-stage1-config.status stage0 \
	config_files
	if $$(grep '^ARCH64=true' ocaml-stage1-Makefile.config > /dev/null) ; \
	then \
		for i in $(ARCHES); do \
		   $(MAKE) --no-print-directory check_arch ARCH=$$i || exit 1; \
		done; \
	else \
		echo "Architecture tests are disabled on 32-bit platforms." ;\
	fi

# The stage0 configure step configures the tree to build pretty much the
# bare minimum that we need for building stage1.
# Currently the middle end for stage0 will match the selected middle end
# for the Flambda backend compiler, except when using Flambda 2, when it
# will be Closure (see configure.ac).
#
# IMPORTANT: We *never* run a configure or config.status script within
# the ocaml subtree. We're going to have three different builds using
# that same subtree, and in particular the stage1 and stage2 builds
# share a single Dune state database (_build/.db), so if anything
# clobbers anything in ocaml/, it could trip something up.
#
# Fortunately, it's never actually necessary: configure scripts can
# trivially be run from anywhere and will generate output wherever you
# run them, and config.status scripts can also be run from anywhere
# (given the right command-line options). So here, for instance, since
# all we want for the moment is the config.status file from the stage0
# configuration, we make a _stage0_configure directory just to run
# configure. We'll run this config.status inside the _build0 copy of
# the ocaml subtree later.
ocaml-stage0-config.status: ocaml/configure.ac
	rm -rf _stage0_configure
	mkdir _stage0_configure
	(cd _stage0_configure && \
	  cat ../configure_opts_stage0 | tr -d '\n' | xargs -0 ../ocaml/configure -C \
	    --prefix=$(stage0_prefix) \
	    --disable-ocamldoc \
	    --disable-ocamltest \
	    --disable-debug-runtime \
	    --disable-instrumented-runtime \
	    --disable-debugger)
	cp _stage0_configure/config.status ocaml-stage0-config.status

# stage1 has already been configured by running the configure script.
# It is configured according to any options requested by the user, including
# selection of the middle end, but the prefix is set to a temporary build
# directory.

# This configures stage2 to have the same configure options as stage1
# except that the prefix is set to the ultimate installation directory.
# Rather than change ocaml/ in place (see comments on
# ocaml-stage0-config.status), we save the config.status file (which is
# executable) and run it from Dune - thus putting the output in just
# stage2's build directory. This is a bit of a pain since by default
# our config.status generates output in subdirectories, which Dune
# doesn't support. So we have to run the config.status once for each
# subdirectory it outputs to. (See the rule for m.h and s.h in
# ocaml/runtime/caml/dune.)

# The stage2 configure can be run by make in parallel with that for
# stage0.

# We add --enable-ocamltest so that the config.status generated here
# can be immediately reused for the "compare" target (see below).
ocaml-stage2-config.status: ocaml/configure.ac
	rm -rf _stage2_configure
	mkdir _stage2_configure
	(cd _stage2_configure && \
	  cat ../configure_opts | xargs -0 ../ocaml/configure -C \
	    --prefix=$(prefix) \
	    --enable-ocamltest \
	    --disable-ocamldoc)
	cp _stage2_configure/config.status ocaml-stage2-config.status

# A copy of the stage1 Makefile.config out of the way of other things
ocaml-stage1-Makefile.config: ocaml-stage1-config.status
	./ocaml-stage1-config.status \
	  --file=ocaml-stage1-Makefile.config:ocaml/Makefile.config.in

# natdynlinkops2:
# We need to augment dune's substitutions so this part isn't so
# difficult.  We use /bin/echo to avoid builtin variants of "echo"
# which don't accept "-n".  Unfortunately if there are no
# NATDYNLINKOPS, we need to provide a harmless option, otherwise dune
# will provide '' on the command line to ocamlopt which causes an
# error.
# CR mshinwell: This should be moved into the upstream dune build system.
#
# flags.sexp:
# Extract compilation flags from Makefile.config of stage1
# and write them to a file that dune can use in stage1 and stage2.
.PHONY: config_files
config_files: ocaml-stage1-Makefile.config
# natdynlinkops2
	cat ocaml-stage1-Makefile.config \
	  | sed 's/^NATDYNLINKOPTS=$$/NATDYNLINKOPTS=-g/' \
	  | grep '^NATDYNLINKOPTS=' \
	  | sed 's/^[^=]*=\(.*\)/-ccopt\n"\1"/' \
	  > ocaml/otherlibs/dynlink/natdynlinkops
	/bin/echo -n $$(cat ocaml-stage1-Makefile.config \
	  | sed 's/^NATDYNLINKOPTS=$$/NATDYNLINKOPTS=-bin-annot/' \
	  | grep '^NATDYNLINKOPTS=' \
	  | sed 's/^[^=]*=\(.*\)/\1/') \
	  > ocaml/otherlibs/dynlink/natdynlinkops2
	if [ "$$(cat ocaml/otherlibs/dynlink/natdynlinkops2)" \
	       != "-bin-annot" ]; \
	then \
	  /bin/echo -n "-ccopt" > ocaml/otherlibs/dynlink/natdynlinkops1; \
	else \
	  /bin/echo -n "-bin-annot" > ocaml/otherlibs/dynlink/natdynlinkops1; \
	fi
# flags.sexp
	grep -q '^FUNCTION_SECTIONS=true' ocaml-stage1-Makefile.config; \
	if [ $$? -eq 0 ] ; then \
	  /bin/echo -n "(:standard -function-sections)" > ocamlopt_flags.sexp; \
	else \
	  /bin/echo -n "(:standard)" > ocamlopt_flags.sexp; \
	fi
	# note: it looks like the use of "$(...)" with a command spanning over
	# two lines triggers a bug in GNU make 3.81, that will as a consequence
	# change the file name. It also looks like the bug is not triggered by
	# "`...`".
	/bin/echo -n "( `grep \"^OC_CFLAGS=\" ocaml-stage1-Makefile.config \
		  	| sed 's/^OC_CFLAGS=//'` )" > oc_cflags.sexp
	/bin/echo -n "( `grep \"^OC_CPPFLAGS=\" ocaml-stage1-Makefile.config \
		| sed 's/^OC_CPPFLAGS=//'` )" > oc_cppflags.sexp
	/bin/echo -n "( `grep \"^SHAREDLIB_CFLAGS=\" ocaml-stage1-Makefile.config \
		| sed 's/^SHAREDLIB_CFLAGS=//'` )" > sharedlib_cflags.sexp

## Build upstream compiler.
## Similar to stage0 except the installation directory
_build_upstream/config.status: ocaml/configure.ac
	rm -rf _build_upstream
	mkdir _build_upstream
	rsync -a $$(pwd)/ocaml/ $$(pwd)/_build_upstream
	(cd _build_upstream && \
	  cat ../configure_opts_stage0 | tr -d '\n' | xargs -0 ./configure -C \
	    --prefix=@prefix@ \
	    --disable-ocamldoc \
	    --enable-ocamltest)

.PHONY: build_upstream
build_upstream: _build_upstream/config.status
	rsync -a $$(pwd)/ocaml/ $$(pwd)/_build_upstream
	(cd _build_upstream && \
	    $(MAKE) world.opt && \
	    $(MAKE) ocamlnat)

.PHONY: install_upstream
install_upstream: build_upstream
	(cd _build_upstream && $(MAKE) install)
	cp ocaml/VERSION $(prefix)/lib/ocaml/

# Most of the installation tree is correctly set up by dune, but we need to
# copy it to the final destination, and rearrange a few things to match
# upstream.
.PHONY: install
install: stage2
	mkdir -p $(prefix)
	rsync --copy-links --chmod=u+rw,go+r -r $(stage2_prefix)/bin $(prefix)
	cp scripts/dummy-ocamlprof.sh $(prefix)/bin/ocamlprof
	cp scripts/dummy-ocamlcp.sh $(prefix)/bin/ocamlcp
	rsync --copy-links --chmod=u+rw,go+r -r $(stage2_prefix)/lib $(prefix)
	rm -f $(prefix)/bin/ocamllex
	ln -s $(prefix)/bin/ocamllex.opt $(prefix)/bin/ocamllex
	rm -f $(prefix)/bin/flambda_backend.main*
	rm -rf $(prefix)/lib/ocaml-variants
	rm -rf $(prefix)/lib/stublibs
	rm -f $(prefix)/lib/ocaml/META
	rm -f $(prefix)/lib/ocaml/dune-package
	rm -f $(prefix)/lib/ocaml/compiler-libs/*.cmo
	cp $(stage2_prefix)/lib/ocaml/compiler-libs/topstart.cmo \
	  $(prefix)/lib/ocaml/compiler-libs/
	rm -rf $(prefix)/lib/flambda_backend
	for file in topdirs opttopdirs; do \
	  for ext in cmi mli cmt cmti; do \
	    cp -f $(prefix)/lib/ocaml/compiler-libs/$${file}.$$ext \
	      $(prefix)/lib/ocaml; \
	  done; \
	done

# This target only runs the dune-based tests, not the upstream testsuite.
# stage2 needs to have been built first.
.PHONY: runtest
runtest:
	# It's a shame that dune needs the stage1 compiler on the path here.
	# Ideally that would be inaccessible within tests (to prevent mistakes
	# such as running "ocamlopt" rather than one of the stage2 binaries).
	ARCH=$(arch) $(dune) build $(dune_flags_stage2) @$(stage2_build)/runtest \
	  --profile=release

# Only needed for running the test tools by hand; runtest will take care of
# building them using Dune
.PHONY: test-tools
test-tools: stage1 find_arch
	ARCH=$(arch) $(dune) build $(dune_flags_stage2) --profile=release \
	  @$(stage2_build)/middle_end/flambda2/tests/tools/all

.PHONY: promote
promote: find_arch
	ARCH=$(arch) $(dune) promote $(dune_flags_stage2)

# The following horror will be removed when work to allow the testsuite to
# run on an installed tree (led by David Allsopp) is completed.
# stage2 needs to have been built first.
.PHONY: runtest-upstream
runtest-upstream:
	rm -rf _runtest
	mkdir _runtest
	cp -a ocaml/testsuite _runtest/testsuite
	# replace backend-specific testsuite/tools with their new versions
	rm _runtest/testsuite/tools/*
	cp -a testsuite/tools/* _runtest/testsuite/tools/
	# replace backend-specific testsuite/tests/asmgen with their new versions
	rm _runtest/testsuite/tests/asmgen/*
	cp -a testsuite/tests/asmgen/* _runtest/testsuite/tests/asmgen/
	(cd _runtest && ln -s ../ocaml/Makefile.tools Makefile.tools)
	(cd _runtest && \
	  ln -s ../$(stage2_build)/ocaml/Makefile.build_config Makefile.build_config)
	(cd _runtest && \
	  ln -s ../ocaml/Makefile.config_if_required Makefile.config_if_required)
	(cd _runtest && \
	  ln -s ../$(stage2_build)/ocaml/Makefile.config Makefile.config)
	cp $(stage2_prefix)/bin/* _runtest/
	# There seems to be an assumption that ocamlc/ocamlopt/ocamllex are
	# bytecode...
	cp -f $(stage2_prefix)/bin/ocamlc.byte _runtest/ocamlc
	cp -f $(stage2_prefix)/bin/ocamlopt.byte _runtest/ocamlopt
	mkdir _runtest/lex
	mv _runtest/ocamllex.byte _runtest/lex/ocamllex
	mkdir _runtest/yacc
	mv _runtest/ocamlyacc _runtest/yacc/
	# Note that stage2_build is relative but stage2_prefix is absolute.
	# CR lmaurer: We should probably decide on one.
	(cd _runtest && ln -s ../$(stage2_build)/ocaml/runtime runtime)
	(cd _runtest && ln -s $(stage2_prefix)/lib/ocaml stdlib)
	# compilerlibs
	mkdir _runtest/compilerlibs
	cp $(stage2_prefix)/lib/ocaml/compiler-libs/*.cma _runtest/compilerlibs
	cp $(stage2_prefix)/lib/ocaml/compiler-libs/*.a _runtest/compilerlibs
	cp $(stage2_prefix)/lib/ocaml/compiler-libs/*.cmxa _runtest/compilerlibs
	mkdir _runtest/toplevel
	cp $(stage2_build)/ocaml/toplevel/.ocamltoplevel.objs/byte/*.cm* \
	  _runtest/toplevel/
	for lib in \
	  ui \
	  algorithms \
	  lattices \
	  numbers \
	  identifiers \
	  kinds \
	  nominal \
	  bound_identifiers \
	  term_basics \
	  terms \
	  from_lambda \
	  cmx \
	  types \
	  simplify \
	  to_cmm \
	  parser; \
	do \
	  cp $(stage2_build)/middle_end/flambda2/$$lib/flambda2_$${lib}.cma \
	    _runtest/compilerlibs; \
	done
	cp $(stage2_build)/middle_end/flambda2/flambda2.cma \
	  _runtest/compilerlibs
	# Various directories are put on the -I paths by tools/Makefile;
	# utils/ is one such, so we just dump the .cm* files in there for
	# various things.
	mkdir _runtest/utils
	cp $(stage2_prefix)/lib/ocaml/compiler-libs/*.cmi _runtest/utils
	cp $(stage2_prefix)/lib/ocaml/compiler-libs/*.cmo _runtest/utils
	cp $(stage2_prefix)/lib/ocaml/compiler-libs/*.cmx _runtest/utils
	cp $(stage2_prefix)/lib/ocaml/*.cmi _runtest/utils
	cp $(stage2_prefix)/lib/ocaml/*.cma _runtest/utils
	cp $(stage2_prefix)/lib/ocaml/*.a _runtest/utils
	cp $(stage2_prefix)/lib/ocaml/*.cmxa _runtest/utils
	cp $(stage2_build)/ocaml/.ocamlcommon.objs/native/config.o _runtest/utils
	# Needed for tests/warnings
	cp ocaml/utils/warnings.ml _runtest/utils
	# Suppress linker errors about -I directories not existing.
	for dir in asmcomp bytecomp driver file_formats lambda middle_end \
	  parsing typing; do ln -s utils _runtest/$$dir; done
	# dynlink
	mkdir -p _runtest/otherlibs/dynlink
	cp $(stage2_prefix)/lib/ocaml/dynlink* _runtest/otherlibs/dynlink
	# stublibs
	mkdir -p _runtest/lib/ocaml/stublibs/
	cp $(stage2_prefix)/lib/ocaml/stublibs/*.so _runtest/lib/ocaml/stublibs
	# str
	mkdir -p _runtest/otherlibs/str
	cp $(stage2_prefix)/lib/ocaml/str*.cmi _runtest/otherlibs/str/
	cp $(stage2_prefix)/lib/ocaml/libstr*.a _runtest/otherlibs/str
	cp $(stage2_prefix)/lib/ocaml/str*.cma _runtest/otherlibs/str
	cp $(stage2_prefix)/lib/ocaml/str*.cmxa _runtest/otherlibs/str
	cp $(stage2_prefix)/lib/ocaml/str*.a _runtest/otherlibs/str
	cp $(stage2_prefix)/lib/ocaml/str*.cmx _runtest/otherlibs/str
	# unix
	mkdir -p _runtest/otherlibs/unix
	cp $(stage2_prefix)/lib/ocaml/unix*.cmi _runtest/otherlibs/unix
	cp $(stage2_prefix)/lib/ocaml/libunix*.a _runtest/otherlibs/unix
	cp $(stage2_prefix)/lib/ocaml/unix*.cma _runtest/otherlibs/unix
	cp $(stage2_prefix)/lib/ocaml/unix*.cmxa _runtest/otherlibs/unix
	cp $(stage2_prefix)/lib/ocaml/unix*.a _runtest/otherlibs/unix
	cp $(stage2_prefix)/lib/ocaml/unix*.cmx _runtest/otherlibs/unix
	# systhreads
	mkdir -p _runtest/otherlibs/systhreads
	cp $(stage2_prefix)/lib/ocaml/threads/*.cmi _runtest/otherlibs/systhreads
	cp $(stage2_prefix)/lib/ocaml/threads/*.cma _runtest/otherlibs/systhreads
	cp $(stage2_prefix)/lib/ocaml/threads/*.a _runtest/otherlibs/systhreads
	cp $(stage2_prefix)/lib/ocaml/threads/*.cmxa _runtest/otherlibs/systhreads
	cp $(stage2_prefix)/lib/ocaml/threads/*.cmx _runtest/otherlibs/systhreads
	# ocamldebug
	mkdir _runtest/debugger
	mv _runtest/ocamldebug _runtest/debugger
	cp $(stage2_build)/ocaml/debugger/.main.eobjs/byte/*.cm* \
	  _runtest/debugger
	# The ast_invariants test needs VERSION to be present.  In fact ideally
	# we should have all the source files in _runtest too for this test,
	# but for the moment we accept it being a weaker check.  We're not
	# working on parts of the compiler that deal with the AST anyway in
	# this repo.
	touch _runtest/VERSION
	# tools
	mkdir _runtest/tools
	cp $(stage2_build)/ocaml/tools/ocamlmklib_byte.bc _runtest/tools/ocamlmklib
	cp $(stage2_build)/tools/ocamlobjinfo_byte.bc _runtest/tools/ocamlobjinfo
	# ocamltest itself
	mkdir _runtest/ocamltest
	# This is deliberately run with the stage0 compiler in case the new
	# one is broken.  As such, we use the stage1 build dir, not that from
	# stage2.
	# This might be causing a spurious rebuild of the runtime
	ARCH=$(arch) $(dune) build $(dune_flags_stage1) --profile=release \
	  $(stage1_build)/ocaml/tools/cmpbyt.bc
	ARCH=$(arch) $(dune) build $(dune_flags_stage1) --profile=release \
	  $(stage1_build)/ocaml/ocamltest/ocamltest.byte
	cp $(stage1_build)/ocaml/tools/cmpbyt.bc _runtest/tools/cmpbyt
	# We should build the native ocamltest too.
	cp $(stage1_build)/ocaml/ocamltest/ocamltest.byte _runtest/ocamltest/ocamltest
	grep -v '^#' testsuite/flambda2-test-list > _runtest/flambda2-test-list
	(export OCAMLSRCDIR=$$(pwd)/_runtest; \
	 export CAML_LD_LIBRARY_PATH=$$(pwd)/_runtest/lib/ocaml/stublibs; \
	 cd _runtest/testsuite \
	  && if $$(which parallel > /dev/null 2>&1); \
             then \
               if [ "$(middle_end)" = "flambda2" ]; then \
                 make list-parallel FILE=$$(pwd)/../flambda2-test-list; \
	       else \
                 make parallel; \
               fi \
             else \
               if [ "$(middle_end)" = "flambda2" ]; then \
                 make list FILE=$$(pwd)/../flambda2-test-list; \
	       else \
                 make all; \
               fi \
             fi)

# Compare the Flambda backend installation tree against the upstream one.
# "make install" needs to have been done first.
#
# We can't use the stage0 installation directory to compare against because
# it won't have been configured with the correct options.  Instead we build
# a fresh upstream compiler using the same configure options as the user
# originally specified when they configured the Flambda backend tree.
.PHONY: compare
compare: _compare/config.status
	rm -f .rsync-output-compare
	rsync -i -a --filter=':- $$(pwd)/ocaml/.gitignore' \
	  $$(pwd)/ocaml/ $$(pwd)/_compare \
	  | grep -v '/$$' \
	  | tee .rsync-output-compare
	if [ -s .rsync-output-compare ] || ! [ -d _compare/_install ]; then \
	  (cd _compare && \
	    $(MAKE) world.opt && \
	    $(MAKE) ocamlnat && \
	    $(MAKE) install); \
	fi
	./scripts/compare.sh $$(pwd)/_compare/_install $(prefix) \
	  $(stage0_prefix)/bin/ocamlobjinfo.opt

# CR mshinwell: Why does the ocamltest build complain about
# Ocaml_directories being missing?
_compare/config.status: ocaml/configure.ac
	rm -rf _compare
	mkdir _compare
	(cd _compare && \
	  cat ../configure_opts | xargs -0 ../ocaml/configure -C \
	    --prefix=$$(pwd)/_install \
	    --disable-stdlib-manpages \
	    --disable-ocamltest \
	    --disable-ocamldoc)

# For Github Actions checks
.PHONY: ci
ci:
	$(MAKE) stage2
	$(MAKE) install
	$(MAKE) runtest
	$(MAKE) runtest-upstream

.PHONY: fmt
fmt:
	ocamlformat -i \
	  $$(find middle_end/flambda2 \
	    \( -name "*.ml" -or -name "*.mli" \) \
	    -and \! \( -name "flambda_parser.*" -or -name "flambda_lex.*" \))
	ocamlformat -i \
	  $$(find backend/cfg \
	    \( -name "*.ml" -or -name "*.mli" \))
	ocamlformat -i tools/merge_archives.ml

.PHONY: check-fmt
check-fmt:
	if [ "$$(git status --porcelain middle_end/flambda2)" != "" ] || \
           [ "$$(git status --porcelain backend/cfg)" != "" ]; then \
	  echo; \
	  echo "Tree must be clean before running 'make check-fmt'"; \
	  exit 1; \
	fi
	$(MAKE) fmt
	if [ "$$(git diff middle_end/flambda2)" != "" ] || \
           [ "$$(git diff backend/cfg)" != "" ] || \
           [ "$$(git diff tools/merge_archives.ml)" != "" ]; then \
	  echo; \
	  echo "The following code was not formatted correctly:"; \
	  echo "(the + side of the diff is how it should be formatted)"; \
	  echo "(working copy now contains correctly-formatted code)"; \
	  echo; \
	  git diff --no-ext-diff; \
	  exit 1; \
	fi
